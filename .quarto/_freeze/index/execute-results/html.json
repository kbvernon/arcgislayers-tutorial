{
  "hash": "cff2c1c6c90e96c8b1ba0a93028601e4",
  "result": {
    "engine": "knitr",
    "markdown": "---\nformat: \n  revealjs:\n    theme: [default, custom.scss]\n    highlight-style: a11y\n    code-line-numbers: false\n    slide-number: true\nexecute: \n  echo: true\nknitr:\n  opts_chunk: \n    collapse: true\n    comment: \"#>\" \n---\n\n\n\n## {.kiss data-background-color=\"#0c0c0c\"}\n\n::: {.absolute right=0 top=100 style=\"width: 65%; text-align: right;\"}\n[Working with REST APIs to access spatial data]{.georgia style=\"font-size: 50px; font-weight: 600;\"}  \nSUDS Workshop\n:::\n\n![](figures/ace-frehley.png){.absolute bottom=10 left=0 width=\"8in\"}\n\n::: {.absolute right=0 bottom=0 style=\"width: 60%; text-align: right;\"}\n2025-10-21  \n[{{< iconify bi:github >}} kbvernon/arcgislayers-tutorial](https://github.com/kbvernon/arcgislayers-tutorial)  \n[{{< iconify bi:music-note-beamed >}} New York Groove](https://www.youtube.com/watch?v=DXeeY9D9u94&list=RDDXeeY9D9u94&start_radio=1)\n:::\n\n## [`arcgislayers`]{.big-font} {.center}\n\n> the core data access package in the R-ArcGIS Bridge, providing [**a unified interface for working with ArcGIS data services**]{style=\"color: #06287e;\"}. As part of the arcgis metapackage, it enables seamless integration between R and the ArcGIS Web GIS ecosystem, including ArcGIS Online, Enterprise, and Location Platform.\n\n{{< iconify bi:link-45deg >}} <https://r.esri.com/arcgislayers/>\n\n{{< iconify bi:person >}} [Josiah Parry](https://github.com/JosiahParry), Senior Product Engineer @ Esri\n\n\n## [Intuition Pumps]{.soft-white .georgia .big-font} {.center data-background-color=\"#0c0c0c\" }\n\n## AGOL query in the browser\n\nGet US Census TIGER/line data\n\n![](figures/agol-query-gui.png){width=\"85%\"}\n\n## AGOL query in the browser\n\nReturn GeoJSON\n\n```json\n{\n  \"type\": \"FeatureCollection\",\n  \"features\": [\n    {\n      \"type\": \"Feature\",\n      \"geometry\": {\n        \"type\": \"Polygon\",\n        \"coordinates\": [\n          [\n            [-111.737567999652, 40.5282020000119],\n            ...,\n            [-111.737567999652, 40.5282020000119]\n          ]\n        ]\n      },\n      \"properties\": {\n        \"NAME\": \"Salt Lake County\"\n      }\n    }\n  ]\n}\n```\n\n## AGOL query in the browser\n\nRead to simple feature\n\n```r\nlibrary(sf)\n\nlong_geojson_string <- '({\"type\":\"FeatureCollection\", ... \"NAME\":\"Salt Lake County\"}}]}'\n\nslco <- read_sf(long_geojson_string)\n```\n\n## {.center}\n\n![](figures/agol-query-gui.gif){fig-align=\"center\"}\n\n## `arcgislayers` in R\n\nGet US Census TIGER/line data\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(arcgislayers)\n\n# connect to a map service\nurl <- file.path(\n  \"https://tigerweb.geo.census.gov\",\n  \"arcgis/rest/services\",\n  \"TIGERweb/State_County/MapServer/1\"\n)\n\nservice <- arc_open(url)\n\n# write and execute http request\nslco <- arc_select(service, where = \"BASENAME='Salt Lake'\")\n```\n:::\n\n\n## `arcgislayers` returns `sf`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nslco[c(\"STATE\", \"BASENAME\")]\n#> Simple feature collection with 1 feature and 2 fields\n#> Geometry type: POLYGON\n#> Dimension:     XY\n#> Bounding box:  xmin: -12496750 ymin: 4926312 xmax: -12418040 ymax: 5000821\n#> Projected CRS: WGS 84 / Pseudo-Mercator\n#>   STATE  BASENAME                       geometry\n#> 1    49 Salt Lake POLYGON ((-12438569 4942999...\n```\n:::\n\n\n## [Why care?]{.soft-white .georgia .big-font} {.center data-background-color=\"#0c0c0c\" }\n\n## Focus on remote access...\n\n1. makes data used for research more accessible,\n2. shifts effort from data management to data processing,\n3. reduces the need for costly data duplication, \n4. supports collaborative research, and \n5. promotes reproducibility.\n\n## Only the `source()` is real!\n\n{{< iconify bi:filetype-json >}} salt-lake.json ~ 462 KB  \n\n{{< iconify bi:file-text >}} salt-lake.R ~ 0.3 KB  \n\nBut sharing the R script is basically sharing the data,  \nsince getting the data is as simple as `source(\"salt-lake.R\")`*.\n\n::: {.absolute bottom=10 style=\"color: #829399; font-size: 22px;\"}\n\\* There are always trade-offs...\n:::\n\n## But also money!\n\n## [HTTP requests?]{.soft-white .georgia .big-font} {.center data-background-color=\"#0c0c0c\" }\n\n## URL components\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(httr2)\n\nurl <- file.path(\n  \"https://tigerweb.geo.census.gov\",\n  \"arcgis/rest/services\",\n  \"TIGERweb/State_County/MapServer/0\"\n)\n\nurl_parse(url)\n#> <httr2_url> https://tigerweb.geo.census.gov/arcgis/rest/services/TIGERweb/State_County/MapServer/0\n#> * scheme: https\n#> * hostname: tigerweb.geo.census.gov\n#> * path: /arcgis/rest/services/TIGERweb/State_County/MapServer/0\n```\n:::\n\n\n## AGOL specifics\n\n\n::: {.cell}\n\n```{.r .cell-code}\nservice <- arc_open(url)\nservice\n#> <FeatureLayer>\n#> Name: States\n#> Geometry Type: esriGeometryPolygon\n#> CRS: 3857\n#> Capabilities: Map,Query,Data\n```\n:::\n\n\n## Building queries\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreq <- request(service[[\"url\"]])\n\n# append queries to endpoint url\nreq |> req_url_query(where = \"NAME='Utah'\", fields = \"NAME\")\n#> <httr2_request>\n#> GET https://tigerweb.geo.census.gov/arcgis/rest/services/TIGERweb/State_County/MapServer/0?where=NAME%3D%27Utah%27&fields=NAME\n#> Body: empty\n\n# insert queries into request body\nreq |> req_body_form(where = \"NAME='Utah'\", fields = \"NAME\")\n#> <httr2_request>\n#> POST https://tigerweb.geo.census.gov/arcgis/rest/services/TIGERweb/State_County/MapServer/0\n#> Body: form data\n```\n:::\n\n\nWhen we pass the service information to `arc_select()` with arguments, it helps \nus build a url query string with `req_url_query()` and then sends that request \nto the service endpoint.\n\n## [Arguments to `arc_select()`]{.soft-white .georgia .big-font} {.center data-background-color=\"#0c0c0c\" }\n\n## `fields` for column selection\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# available fields at this service endpoint\nlist_fields(service)[[\"name\"]]\n#>  [1] \"MTFCC\"      \"OID\"        \"GEOID\"      \"STATE\"      \"STATENS\"   \n#>  [6] \"BASENAME\"   \"NAME\"       \"LSADC\"      \"FUNCSTAT\"   \"AREALAND\"  \n#> [11] \"AREAWATER\"  \"REGION\"     \"DIVISION\"   \"STUSAB\"     \"STGEOMETRY\"\n#> [16] \"CENTLAT\"    \"CENTLON\"    \"INTPTLAT\"   \"INTPTLON\"   \"OBJECTID\"\n\nstates <- arc_select(service, fields = \"NAME\")\nnames(states)\n#> [1] \"NAME\"     \"geometry\"\n```\n:::\n\n\n## `where` for SQL queries\n\n\n::: {.cell}\n\n```{.r .cell-code}\nintermountain <- arc_select(service, where = \"NAME IN ('Utah', 'Nevada')\")\n\nintermountain[[\"NAME\"]]\n#> [1] \"Nevada\" \"Utah\"\n```\n:::\n\n\n## `crs` for return spatial reference\n\n```r\nlibrary(sf)\n\nstates <- arc_select(service, crs = 26912)\n\nst_crs(states)$epsg\n#> [1] 26912\n```\n\n## `geometry` for returning geometry\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstate_attributes <- arc_select(service, geometry = FALSE)\n\nstate_attributes[c(\"STATE\", \"NAME\")]\n#> Simple feature collection with 56 features and 2 fields\n#> Geometry type: POLYGON\n#> Dimension:     XY\n#> Bounding box:  xmin: NA ymin: NA xmax: NA ymax: NA\n#> Projected CRS: WGS 84 / Pseudo-Mercator\n#> First 10 features:\n#>    STATE           NAME      geometry\n#> 1     36       New York POLYGON EMPTY\n#> 2     32         Nevada POLYGON EMPTY\n#> 3     02         Alaska POLYGON EMPTY\n#> 4     60 American Samoa POLYGON EMPTY\n#> 5     50        Vermont POLYGON EMPTY\n#> 6     09    Connecticut POLYGON EMPTY\n#> 7     10       Delaware POLYGON EMPTY\n#> 8     35     New Mexico POLYGON EMPTY\n#> 9     37 North Carolina POLYGON EMPTY\n#> 10    55      Wisconsin POLYGON EMPTY\n```\n:::\n\n\n## `filter_geom` for spatial filters\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# basins (huc6) of utah\nwbd_url <- file.path(\n  \"https://hydrowfs.nationalmap.gov\",\n  \"arcgis/rest/services\",\n  \"wbd/MapServer/3\"\n)\n\n# watershed boundaries database service\nwbd <- arc_open(wbd_url)\n\nutah <- states |> subset(NAME == \"Utah\")\n\nbasins <- arc_select(wbd, filter_geom = st_geometry(utah))\n\nbasins[[\"name\"]]\n#>  [1] \"Lower Green\"                  \"Colorado Headwaters\"         \n#>  [3] \"Weber\"                        \"Jordan\"                      \n#>  [5] \"Lower San Juan\"               \"Upper Colorado-Dirty Devil\"  \n#>  [7] \"Upper Colorado-Dolores\"       \"Upper Green\"                 \n#>  [9] \"White-Yampa\"                  \"Lower Colorado-Lake Mead\"    \n#> [11] \"Lower Bear\"                   \"Upper Bear\"                  \n#> [13] \"Great Salt Lake\"              \"Escalante Desert-Sevier Lake\"\n#> [15] \"Upper Snake\"\n```\n:::\n\n\n## `predicate` for spatial relation\n\n```r\n# intersects is the default\nbasins <- arc_select(\n  wbd,\n  filter_geom = st_geometry(utah),\n  predicate = \"within\"\n)\n\nbasins[[\"name\"]]\n#> [1] \"Jordan\"\n```\n\n::: {.absolute bottom=10 style=\"color: #829399; font-size: 22px;\"}\n\\* This actually doesn't work. There's a bug in how the predicate is applied.\n:::",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}